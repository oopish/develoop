Main
====

@todo describe


#### The main class for Pegdev

    class Main
      C: ªC
      toString: -> "[object #{@C}]"

      constructor: (config={}) ->




Properties
----------


#### `pegjs <xx>`
Xx. @todo describe

        @pegjs = PEG


#### `aceGrammar <xx>`
Xx. @todo describe

        @aceGrammar = AceGrammar


#### `pegRules <array of PegRules>`
Xx. @todo describe

        @pegRules = []


#### `pegRuleLut <object of PegRules>`
Xx. @todo describe

        @pegRuleLut = {}




Init
----

Initialize the instance. 

        @init()




Methods
-------


#### `init()`

Xx. @todo describe

      init: ->
        rule = new PegRule @,
          label:       '_interpolation'
          humanName:    'Interpolation'
          initializer: """
            function stringProcess(chars) {
              return 'I found ' + chars.join('') + '!';
            }
            """
          rule: '  ' + """
            = '`' chars:_string_not_backtick* '`'
                { return stringProcess(chars); }
            """
        @pegRules.push rule
        @pegRuleLut[rule.label] = rule

        rule = new PegRule @,
          label:       '_string_not_backtick'
          humanName:    'String Not Backtick'
          rule: '  ' + """
            = !'`' char:_string_char { return char; }
            """
        @pegRules.push rule
        @pegRuleLut[rule.label] = rule

        rule = new PegRule @,
          label:       '_string_char'
          humanName:    'String Character'
          rule: '  ' + """
            = "\\\\" char:. { return "\\\\" + char; }
              / .
            """
        @pegRules.push rule
        @pegRuleLut[rule.label] = rule




#### `renderInitializer()`

Xx. @todo describe

      renderInitializer: ->

Count the number of inert rules. 

        inertTally = 0
        for rule in @pegRules then if rule.inert then inertTally++

Show the initializer. 

        out = ["//// Initializer generated by #{ªC} #{ªV}\n\n"]
        if 0 == @pegRules.length or @pegRules.length == inertTally
          out.push "//// No initializer needed. \n\n"
        else
          out.push "//// Begin initializer. \n\n{"
          out = out.concat(rule.getInitializer() for rule in @pegRules)
          out.push '} // end initializer\n\n'

Return the result as a string. 

        out.join('\n') + '\n\n'




#### `renderRules()`

Xx. @todo describe

      renderRules: ->

Count the number of inert rules. 

        inertTally = 0
        for rule in @pegRules then if rule.inert then inertTally++

Show the active rules, if any. 

        out = ["//// Rules generated by #{ªC} #{ªV}\n\n"]
        if 0 == @pegRules.length
          out.push "//// No rules have been defined. \n"
          out.push "start = ''"
        else if @pegRules.length == inertTally
          out.push "//// The #{@pegRules.length} rules are inert. \n"
          out.push "start = ''"
        else
          out.push "//// Begin rules. \n"
          out = out.concat(rule.getRule() for rule in @pegRules)
          out.push "\n\n//// #{@pegRules.length} rules, #{inertTally} inert. \n"

Return the result as a string. 

        out.join('\n') + '\n\n'




#### `renderMode()`

Xx. @todo describe

      renderMode: ->

Count the number of inert rules. 

        inertTally = 0
        for rule in @pegRules then if rule.inert then inertTally++

Show the active rules, if any. 

        out = ["//// Mode generated by #{ªC} #{ªV}\n\n"]
        if 0 == @pegRules.length
          out.push "//// No rules have been defined. \n"
          out.push "modeGrammar = {}"
        else if @pegRules.length == inertTally
          out.push "//// The #{@pegRules.length} rules are inert. \n"
          out.push "modeGrammar = {}"
        else
          out.push "//// Begin modes. \n"
          out.push "modeGrammar = {"
          out.push """

    //// Prefix ID for regular expressions used in the highlighter. 
    "RegExpID" : "RegExp::",

    //// Style model. 
    Style: {
    """
          for rule in @pegRules
            unless rule.inert
              for key, val of rule.getModeStyles()
                out.push '  ' + key + ': "' + val + '",'
          out[out.length-1] = out[out.length-1].slice 0, -1 # trailing comma

          out.push """
    },

    /*
        "commentBlock":         "comment",
        "cdataBlock":           "string",
        "closeTag":             "keyword",
        "attribute":            "variable",
        "number":               "constant.numeric",
        "string":               "string"
    */


    //// Lexical model. 
    Lex: {
    """
          for rule in @pegRules
            unless rule.inert
              for key, val of rule.getModeLexes()
                out.push '  ' + key + ': ' + val + ','
          out[out.length-1] = out[out.length-1].slice 0, -1 # trailing comma

          out.push """
    },

    /*
        "commentBlock" : {
            "type" : "comment",
            "tokens" : [
                // block comments
                // start,    end  delims
                [ "<!--",    "-->" ]
            ]
        }
    */


    //// Syntax model (optional). @todo
    Syntax: {
    },


    //// What to parse and in what order. 
    Parser: [
    """
          for rule in @pegRules
            unless rule.inert
              out.push "  '" + rule.label + "',"
          out[out.length-1] = out[out.length-1].slice 0, -1 # trailing comma

          out.push """
    ]



          """
          out.push "}"

Return the result as a string. 

        out.join('\n') + '\n\n'




Functions
---------


#### `xx()`
- `xx <xx>`  Xx 

Xx. @todo describe

    xx = (xx) ->



